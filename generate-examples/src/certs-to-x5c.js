// Reads EC P-256 PEM private key and certs and outputs a private and public JWK pair.
//
// PEM format for P-256 (prime256v1) private key
// -----BEGIN PRIVATE KEY-----
// <-- multi-line base64 encoding of ASN.1:
//   [0..35]: header (36 bytes)
//   [36..67]: private key (d value, 32 bytes)
//   [68..72]: public key header
//   [73]: 0x04 (uncompressed public key)
//   [74..105]: x
//   [106..137]: y
// -->
// -----END PRIVATE KEY-----
//
// PEM format of cert
// 

const fs = require('fs');
const program = require('commander');
const jose = require('node-jose');
const { Buffer } = require('buffer');

const PRIVATE = 0;
const EC_P256_ASN1_PRIVATE_KEY_HEADER_HEX = "308187020100301306072a8648ce3d020106082a8648ce3d030107046d306b0201010420";
const EC_P256_ASN1_PUBLIC_KEY_HEADER_HEX = "a144034200";
const EC_COMPRESSED_KEY_HEX = "04";

// PEM to DER encoding
// Drop the first and last lines (BEGIN/END markers), concatenate the others, base64-decode
const PEMtoDER = (pem) => Buffer.from(pem.split(/\r?\n/).slice(1,-2).join(), "base64");

// DER to JWK with x5c attribute, returns [private,public] keys
const DERtoJWK = async (key, certs) => {
    // make expected header and values are good
    if (key.slice(0,36).toString('hex') !== EC_P256_ASN1_PRIVATE_KEY_HEADER_HEX) throw "Invalid EC P-256 ASN.1 private key header";
    if (key.slice(68,73).toString('hex') !== EC_P256_ASN1_PUBLIC_KEY_HEADER_HEX) throw "Invalid EC P-256 ASN.1 public key header";
    if (key.slice(73,74).toString('hex') !== EC_COMPRESSED_KEY_HEX) throw "Invalid EC public key encoding";
    const d = key.slice(36,68);
    const x = key.slice(74,106);
    const y = key.slice(106,138);

    const jwk = await jose.JWK.asKey(
        {
            "kty":"EC",
            "use":"sig",
            "alg":"ES256",
            "crv":"P-256",
            "d":jose.util.base64url.encode(d),
            "x":jose.util.base64url.encode(x),
            "y":jose.util.base64url.encode(y),
            "x5c":certs.map(cert => cert.toString('base64'))
            // SHA-256 kid auto-generated by key import
        }
    );
    return [JSON.stringify(jwk.toJSON(true)), JSON.stringify(jwk.toJSON(false))]
}

const main = async (options) => {
    if (!options.key || !options.cert) {
        console.log("Missing --key or --cert argument");
        program.help();
    }
    try {
        // open or create public/private key stores
        const getStore = async path => fs.existsSync(path)  ? await jose.JWK.asKeyStore(JSON.parse(fs.readFileSync(path)))  : jose.JWK.createKeyStore();
        const store = [await getStore(options.private), await getStore(options.public)];

        // read and convert input key and certs to DER format
        const keyFile = PEMtoDER(fs.readFileSync(options.key,'UTF-8'));
        const certFiles = options.cert.map(certPath => PEMtoDER(fs.readFileSync(certPath,'UTF-8')));

        // convert DER key to JWK, adding a x5c value with cert chain
        keys = await DERtoJWK(keyFile, certFiles);
        
        // output public/private key stores with new key
        await Promise.all(keys.map( async (k,i) => {
            await store[i].add(keys[i]);
            const isPrivate = (i == PRIVATE); 
            fs.writeFileSync(isPrivate ? options.private : options.public, JSON.stringify(store[i].toJSON(isPrivate), null, 2));
        }))
    } catch (err) {
        console.log(err);
    }
}

program.option('-k, --key <key>', 'path to the P-256 EC PEM private key');
program.option('-c, --cert <cert>', 'path to a certificate to add to the x5c chain (repeatable, add in chain order: leaf first, root last)', (cert, certs) => certs.concat([cert]), []);
program.option('-p, --public <public>', 'path to the public JWK set to create or add the new key to', 'issuer.jwks.public.json');
program.option('-s, --private <private>', 'path to the private JWK set to create or add the new key to', 'issuer.jwks.private.json');
program.parse(process.argv);
main(program.opts());
