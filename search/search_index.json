{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Status \u00b6 Draft implementation guide authored with input from technology and lab vendors; created in conjunction with four independent software implementations. Contributing \u00b6 To propose changes, please use GitHub Issues or create a Pull Request . Overview Video (November 2020) \u00b6 https://youtu.be/UdlmRoJK1Yg Introduction -- Health Cards \u00b6 This implementation guide provides a framework for \"Health Cards\", with a short term goal to enable a consumer to receive COVID-19 Immunization or lab results and present these results to another party in a verifiable manner . Key use cases include conveying point-in-time infection status for return-to-workplace and travel. This approach should also support documentation of immunization status and other health details. Because we must ensure end-user privacy and because Health Cards must work across organizational and jurisdictional boundaries, we are building on international open standards and decentralized infrastructure. Conceptual Model \u00b6 Issuer (e.g., a lab) generates verifiable credentials Holder stores credentials and presents them at will Verifier receives credentials from holder and ensures they are properly signed Design Goals \u00b6 Support end-to-end workflow where users receive and present relevant healthcare data Enable workflow with open standards Support strong cryptographic signatures Support binding credentials to keys stored on a user's device Enable privacy preserving data presentations for specific use cases Start Small -- Think Big \u00b6 We enable Health Cards by defining building blocks that can be used across healthcare. The core building block allows us to aggregate data into meaningful sets, signed by an issuer, and stored/presented by a consumer as needed. The broader set of use cases might eventually include: Managing an immunization record that can be shared with schools or employers, or for travel Sharing verifiable health history data with clinical research studies Sharing voluntary data with public health agencies Sharing questionnaire responses with healthcare providers Despite this broad scope, our short-term definition of success requires that we: Represent \"Health Cards\" in a \"Health Wallet\", focusing on COVID-19 status Ensure that each role (issuer, holder, app) can be implemented by any organization following open standards, provided they sign on to the relevant trust framework Align with a longer term vision for standards-based decentralized identity, where each role (issuer, holder, app) User Experience \u00b6 Install a \"Health Wallet\" app Connect the Health Wallet to a lab account Save a COVID-19 results card from the lab to the Health Wallet When a user wants to share COVID-19 results with a verifier: a) Open Health Wallet b) Scan a QR code displayed by verifier c) Agree when prompted with \"Share COVID-19 results with {Verifier Name }?\" Demo \u00b6 Sometimes it's easiest to learn by seeing. For an end-to-end demonstration including Mobile Wallet, Lab API, and Verifier, see c19.cards (source code on GitHub -- and if you want to learn how to test your own components against the demo site, see README.md ). Demo Mobile Wallet: Home Screen Demo Mobile Wallet Approval Screen Design Considerations \u00b6 This section outlines higher-level design considerations. See \"Protocol Details\" below for technical details. Data Flow \u00b6 Each step in the flow must have well-defined inputs and outputs. For each step we define at least one required data transfer method to establish a basis for interoperability. Connecting Health Wallet to Lab Required method: OpenID Connect (OIDC) redirect + form_post flow Optional entry point: FHIR $HealthWallet.connect operation to begin the OIDC redirect Getting credentials into Health Wallet Required method: File download Optional method: FHIR API Access Presenting credentials to Verifier Required method: OpenID Connect (OIDC) redirect + form_post flow (assumes devices are online) Optional method: Direct device-to-device connections (e.g. Bluetooth, NFC -- out of scope in the short term) Trust \u00b6 Which issuers can participate, which test results should be considered, and how do verifiers learn this information? At a pilot project level : Which Issuers can participate? We'll work with a willing set of issuers and define expectations/requirements Verifiers will learn the list of participating issuers out of band; each issuer will be associated with a public URL Verifiers will discover public keys associated with an issuer via .well-known DID URLs For transparency, we'll publish a list of participating organizations in a public directory Which lab tests should be considered in decision-making? We'll create or identify FHIR profiles for each lab test that define required fields, vocabularies, etc. Verifiers will learn out of band about which lab tests should be considered in decision-making; this set is expected to evolve over time as new tests are developed and as our scientific understanding evolves In a post-pilot deployment : a network of participants would define and agree to a formal Trust Framework. This is still TBD. Privacy \u00b6 It is an explicit design goal to let the holder only disclose a minimum amount of information to a verifier. The information required to be disclosed is use-case dependent, and -- particularly in a healthcare setting -- it can be difficult for lay people to judge which data elements are necessary to be shared. To start, the granularity of information disclosure will be at the level of an entire credential (i.e., a user can select \"which cards\" to share from a Health Wallet, and each card is shared wholesale). The credentials are designed to only include the minimum information necessary for a given use case. If we identify optional data elements for a given use case, we might incorporate them into credentials by including a cryptographic hash of their values instead of embedding values directly. Longer term we can provide more granular options using techniques like zero-knowledge proofs, or by allowing a trusted intermediary to sumamrize results in a just-in-time fashion. Data Model \u00b6 The credential's data is represented in FHIR as outlined in Modeling Verifiable Credentials in FHIR Protocol Details \u00b6 Install a \u201cHealth Wallet\u201d app \u00b6 In this step, the user installs a standards-based mobile app. The app generates a decentralized identifier on behalf of the user, including: a key of type JsonWebKey2020 to enable verification of JWT signatures created by the wallet, using the \"alg\": \"ES256\" signature algorithm a key of type JsonWebKey2020 to enable encryption of JWE payloads created for this wallet, using the \"alg\": \"ECDH-ES\" and \"enc\": \"A256GCM\" encryption algorithm Signature and encryption algorithms There are different cryptographic algorithms, with trade-offs. It's useful to pick algorithms for consistent implementations -- so we're starting with ES256 for verification and ECDH-ES + A256GCM for encryption, but should continue to evaluate this choice as requirements emerge. This identifier conforms to the did:ion method . The did:ion method is an implementation of the Sidetree specification : a spec for DID methods using distributed ledgers. ION DIDs will be used to secure interactions with the issuer and the verifier, from here on out. DID Methods There are different DID methods, with trade-offs. It's useful to pick an approach that: works for issuers as well as holders works peer-to-peer or anchored to a public record supports key rotation supports distinct keys per-device supports service endpoint discovery So we're starting with did:ion , but should continue to evaluate this choice as requirements emerge. Long-form vs. Short-form DIDs did:ion , a Sidetree-compliant DID method, supports both long and short form DIDs. In brief, a long-form DID can be resolved to a DID Document on its own: it does not require a blockchain query to provide information about the public key information state of an identity. A short-form DID requires a blockchain query to resolve a DID Document and requires that the corresponding long-form DID be persisted to the blockchain before the short-form DID is resolvable. As such, communicating via short-form DIDs requires more capabilities/infrastructure: namely integrating with a Sidetree node to resolve these short-form DIDs. However, this infrastructure enables a more robust security model. You need to persist a DID Document in the blockchain to resolve a short-form DID, persisting a DID Document in the blockchain enables a DID to be updated via key revocation, key addition, etc. Check out the documentation on DID URI Composition and DID Resolution for more details. This implementation guide recommends using strictly long-form ION DIDs at this time. Determining keys and service endpoints from a long-form ION DID Given a long-form ION DID, any participant can follow the ION DID Resolution algorithm to determine the associated DID Document. Within the DID Document you can identify the following: Encryption keys used for key agreement when performing ECDH-ES encryption. Encryption keys can be identified as entries in the verificationMethod[] array whose publicKeyJwk.alg is \"ECDH-ES\" . The Key IDs for all encryption keys SHOULD be listed in the keyAgreement[] array. Signing keys used for ES256 signatures. Signing keys can be identified as entries in the verificationMethod[] array whose publicKeyJwk.alg is \"ES256\" . The Key IDs for all signing keys SHOULD be listed in the authentication[] array. Linked Domains used for issuers with a public web presence. Linked Domains can found in the service[] array, using the serviceEndpoint property on entries with a type of \"LinkedDomains\" . For example, the following fragment of a DID Document contains one signing key, one encryption key, and one linked domain (note that id and @context properties are omitted for brevity): ... \"service\": [ { \"id\": \"#linked-domain-1\", \"type\": \"LinkedDomains\", \"serviceEndpoint\": \"https://lab.example.com\" }, \"verificationMethod\": [ { \"id\": \"#signing-key-1\", \"controller\": \"\", \"type\": \"JsonWebKey2020\", \"publicKeyJwk\": { \"alg\": \"ES256\", \"crv\": \"P-256\", \"kty\": \"EC\", \"x\": \"fsjHQujKrtGxrw4LTpLqIhGVd1i7J7aOIlOxnDoefa8\", \"y\": \"eGOSyJ_fT1xduW-K4aZwh2BBvRGAaTm_jiMB9EWW6oQ\" } }, { \"id\": \"#encryption-key-1\", \"controller\": \"\", \"type\": \"JsonWebKey2020\", \"publicKeyJwk\": { \"alg\": \"ECDH-ES\", \"crv\": \"P-256\", \"kty\": \"EC\", \"x\": \"xds4tFXqH6TFXdRxevqR8xEFgUgTGK_Of0QhGlmg4DY\", \"y\": \"2EpP5ef2-YWmi2aIZcFADG88PyNfRoApfzN81i5aZuE\" } } ], \"authentication\": [ \"#signing-key-1\" ], \"keyAgreement\": [ \"#encryption-key-1\" ] ... Connect Health Wallet to Lab Account \u00b6 In this step, the lab learns about the end-user's DID. To accomplish this, the lab initiates an OpenID Connect request associated with the user's account (e.g., by displaying a link or a QR code in the portal, or by hosting a FHIR API endpoint that allows a third-party app to initiate an OIDC request). The specific OpenID Connect profile we use is called \"DID SIOP\" . Discovering DIDs for labs To ensure that all parties can maintain an up-to-date list of DIDs for known labs, each lab hosts a /.well-known/did-configuration.json file on the same domain as .registration.client_uri lives on, so parties such as the Health Wallet app can maintain a list of DIDs for each domain. sequenceDiagram participant Device as User's Device participant Lab Device ->> Device: Create users DID:ION: keys Lab ->> Lab: Create DID:ION: keys note over Device: Later, either [A], [B] or [C]... Lab -->> Device: [A] Click `openid://` link on issuer's portal Lab -->> Device: [B] Scan QR code or NFC tag with `openid://` link Device -->> Lab: [C] FHIR $HealthWallet.connect Lab -->> Device: [C] Return `openid://` link in FHIR Parameters resource Device ->> Device: React to `openid` link Device ->> Device: Validate prompt note over Device: Ask user to connect Device ->> Lab: Issue request to `request_uri` Lab ->> Lab: Generate DID SIOP request with lab's keys Lab ->> Device: Return DID SIOP Request Device ->> Device: Validate DID SIOP JWT note over Device: Ask user to share keys Device ->> Device: Formulate DID SIOP Response Device ->> Lab: Submit response ([C] with Authorization header) Lab ->> Lab: Store keys to user account Lab ->> Device: Ack DID SIOP Request Discovery The lab constructs an OIDC request, which is displayed to the user (newlines and spaces added for clarity): openid://? response_type=id_token &scope=did_authn &request_uri=<<URL where request object can be found>> &client_id=<<URL where response object will be posted>> By using this URI-based approach, the lab can choose to display a static QR code printed on a sticker at the check-in counter, generating the signed request objects dynamically each time a client dereferences the request_uri . Simplifying the workflow when a FHIR API connection exists A SMART on FHIR Server can advertise support for issuing VCs according to this specification by adding the health-cards capability and the __HealthWallet.* scope to its .well-known/smart-configuration JSON file. For example: { \"authorization_endpoint\": \"https://ehr.example.com/auth/authorize\", \"token_endpoint\": \"https://ehr.example.com/auth/token\", \"token_endpoint_auth_methods_supported\": [\"client_secret_basic\"], \"scopes_supported\": [\"__HealthWallet.*\", \"launch\", \"launch/patient\", \"patient/*.*\", \"offline_access\"], \"response_types_supported\": [\"code\", \"code id_token\", \"id_token\", \"refresh_token\"], \"capabilities\": [\"health-cards\", \"launch-standalone\", \"context-standalone-patient\", \"client-confidential-symmetric\"] } If the Health Wallet app already has a FHIR API connection to the issuer that includes the __HealthWallet.* scope, the app can begin an OIDC connection by invoking the $HealthWallet.connect operation: GET /Patient/:id/$HealthWallet.connect The operation returns a FHIR Parameters resource with the OIDC request URL: { \"resourceType\" : \"Parameters\" , \"parameter\" : [{ \"name\" : \"openidUrl\" , \"valueUri\" : \"openid://?response_type=...\" }] } This allows the Health Wallet to begin the connection workflow directly, without requiring the user to sign into the lab portal or take any extra steps. This is an optional entry point for the connection workflow; it does not change the subsequent steps. DID SIOP Request The <<URL where request object can be found>> in request_uri can be dereferened to a DID SIOP Request . This is a signed JWT that will have a DID as its kid . With a header like: { \"alg\" : \"ES256\" , \"typ\" : \"JWT\" , \"kid\" : \"did:ion:<<identifier for lab>>#<<verification-key-id>>\" } And a payload like: { \"iss\" : \"did:ion:<<identifier for lab>>\" , \"response_type\" : \"id_token\" , \"client_id\" : \"<<URL where response object will be posted>>\" , \"scope\" : \"openid did_authn\" , \"response_mode\" : \"form_post\" , \"response_context\" : \"wallet\" , \"nonce\" : \"<<unique value>>\" , \"state\" : \"<<client-supplied value, possibly empty>>\" , \"registration\" : { \"id_token_signed_response_alg\" : \"ES256\" , \"id_token_encrypted_response_alg\" : \"ECDH-ES\" , \"id_token_encrypted_response_enc\" : \"A256GCM\" , \"client_uri\" : \"<<base URL for lab>>\" } } The id_token_encrypted_response_* parameters are optional and, if present, signal that the response to this request should be encrypted, not just signed. Request Options response_mode : the Health Wallet should recognize and support form_post and fragment modes. response_context of wallet allows the relying party to indicate that the wallet can issue a response in its own user agent context, effectively performing a \"headless\" submission and keeping the user in the wallet at the end of the interaction rather than redirecting back to the relying party. Note: The wallet response context is only suitable in combination with a SMART on FHIR or other authenticated API connection, to prevent session fixation attacks. Otherwise, the relying party must receive its response in the system browser context, and must verify that the session where the request was generated and the session where the response was provided are both sessions for the same end-user. DID SIOP Request Validation In addition to the regular DID SIOP request validation , the Health Wallet retrieves the well-known configuration from the domain corresponding to registration.client_uri and verifies that the kid in the request header is a DID associated with the domain. Bug in spec: Do NOT attempt to validate according to OIDC Core 7.5 because this applies to the response, not the request. DID SIOP Response The Health Wallet displays a message to the user asking something like \"Connect to lab.example.com?\" (based on the registration.client_uri value). If the user agrees, the Health Wallet constructs a DID SIOP Response object with a header like: { \"alg\" : \"ES256\" , \"typ\" : \"JWT\" , \"kid\" : \"did:ion:<<identifer for user>>#<<verification-key-id>>\" } And a payload like: { \"iss\" : \"https://self-issued.me\" , \"did\" : \"did:ion:<<identifier for user>>\" , \"aud\" : \"<<client_id from the request>>\" , \"nonce\" : \"<<unique value>>\" , \"exp\" : <<expira t io n t ime as JSON nu mber o f seco n ds si n ce epoch>> , \"iat\" : <<issua n ce t ime as JSON nu mber o f seco n ds si n ce epoch>> , \"sub_jwk\" : { \"crv\" : \"P-256\" , \"kid\" : \"did:ion:<<identifer for user>>#<<verification-key-id>>\" , \"kty\" : \"EC\" , \"x\" : \"<<curve's X coordinate>>\" , \"y\" : \"<<curve's Y coordinate>>\" }, } The response is signed as a JWS with the user's DID and optionally encrypted using the lab's DID (if the request specified id_token_encrypted_response_* ). The latter step requires looking inside the DID Document for an encryption key, which can be used for encrypting a payload for this party. TODO: Show the header for the JWE around it Finally, the Health Wallet submits the id_token and state values back to the client's URL (conveyed in the client_id request field). If response_context is wallet , the Health Wallet may issue an HTTP call directly to the client's URL. Otherwise, the Health Wallet submits a response in the context of the system browser. For example, if response_mode is form_post and response_context is wallet , the response might be sumitted as: POST <<URL where response object will be posted>> Content-type: application/x-www-form-urlencoded id_token=<<DID SIOP Response Object as JWS or JWE>> &state=<<state value from DID SIOP Request Object, if any>> Authorizing FHIR Operations If the Health Wallet received the openid link via the FHIR $HealthWallet.connect operation, the DID SIOP is authorized by including the SMART on FHIR bearer token in an Authorization header. Lab Generates Results \u00b6 When the lab performs tests and the results come in, the lab creates a FHIR payload and a corresponding VC. sequenceDiagram participant Holder participant Lab note over Holder, Lab: Earlier... Lab ->> Lab: Generate Lab's DID Holder -->> Lab: Upload DID Lab ->> Lab: If labs for holder already exist: re-generate VCs note over Lab, Holder: Lab Result Created Lab ->> Lab: Generate FHIR Representation Lab ->> Lab: Generate VC Representation Lab ->> Lab: Generate JWT Payload including Holder DID (if known) and sign Lab ->> Lab: Store on holder's account note over Lab, Holder: Later... Lab ->> Holder: Holder downloads VCs See Modeling Verifiable Credentials in FHIR for details. The overall VC structure looks like the following: VCs look different when represented as JWTs The example below shows a VC using the \"vanilla\" JSON representation. When packaging a VC into a JSON Web Token payload, there are a few differences, to retain compatibility with standard JWT claims. For example, compare this \"vanilla\" JSON representation with its corresponding JWT payload . Note that in the JWT payload, most properties have been pushed into a .vc claim. { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" ], \"type\" : [ \"VerifiableCredential\" , \"https://smarthealth.cards#covid19\" , ], \"issuer\" : \"<<did:ion identifier for lab>>\" , \"issuanceDate\" : \"2020-05-01T11:59:00-07:00\" , \"credentialSubject\" : { \"id\" : \"<<did:identifier for holder if known>>\" , \"fhirVersion\" : \"<<FHIR Version>>\" , \"fhirBundle\" : { \"resourceType\" : \"Bundle\" , \"type\" : \"collection\" , \"entry\" : [ <<FHIR Resources>> ] } } } Lab Results are Finalized \u00b6 In this step, the user learns that new lab results are available (e.g., by receiving a text message or email notification). To facilitate this workflow, the lab can include a link to help the user download the credentials directly, e.g., from at a login-protected page in the Lab's patient portal. The file should be served with a .fhir-backed-vc file extension, so the Health Wallet app can be configured to recognize this extension. Contents should be a JSON object containing an array of Verifiable Credential JWTs, which MAY be either JWE or JWS, at the issuer's discretion: in the case where the user has NOT connected a wallet to the issuer in advance, these will necessarily be JWS values, since no encryption key is known in the case where the user has connected a health wallet to the issuer, the issuer MAY choose to encrypt the .fhir-backed-vc file using a key from the Health Wallet's registered DID { \"verifiableCredential\" : [ \"<<Verifiable Credential as JWE or JWS (see above)>>\" , \"<<Verifiable Credential as JWE or JWS (see above)>>\" ] } Finally, the Health Wallet asks the user if they want to save any/all of the supplied credentials. Requesting VCs through the FHIR API The file download is the lowest common denominator. For a more seamless user experience when FHIR API connections are already in place, results may also be conveyed through a FHIR API $HealthWallet.issueVc operation defined here. FHIR API Example Approach $HealthWallet.issueVc Operation A Health Wallet can POST /Patient/:id/$HealthWallet.issueVc to a FHIR-enabled issuer to request the generation of a specific type of Health Card. The body of the POST looks like: { \"resourceType\" : \"Parameters\" , \"parameter\" : [{ \"name\" : \"credentialType\" , \"valueUri\" : \"https://smarthealth.cards#covid19\" }] } The credentialType and presentationContext parameters are both required. By default, the issuer will decide which identity claims to include based on the requested presentationContext . If the Health Wallet wants to fine-tune identity claims in the generated credentials, it can provide an explicit list of one or more includeIdentityClaim s, which will limit the claims included in the VC. For example, to request that only name be included: { \"resourceType\" : \"Parameters\" , \"parameter\" : [{ \"name\" : \"credentialType\" , \"valueUri\" : \"https://smarthealth.cards#covid19\" }, { \"name\" : \"includeIdentityClaim\" , \"valueString\" : \"Patient.name\" }, { \"name\" : \"encryptForKeyId\" , \"valueString\" : \"#encryption-key-1\" }] } If no encryptForKeyId parameter is supplied, then the signed VC is returned unencrypted. To request encryption, the client includes an encryptForKeyId parameter with a valueString , indicating the requested encryption key ID, starting with # . This ensures that even if the client's DID document includes more than one encryption key, the server will know which one to use for encrypting this payload. The response is a Parameters resource that includes one more more verifiableCredential values like: { \"resourceType\" : \"Parameters\" , \"parameter\" :[{ \"name\" : \"verifiableCredential\" , \"valueAttachment\" :{ \"data\" : \"<<base64 encoded VC JWS or JWE>>\" } }] } If a client calls $HealthWallet.issueVc when no DID has been bound to the Patient record, the server responds with a FHIR OperationOutcome including the \"no-did-bound\" code: { \"resourceType\" : \"OperationOutcome\" , \"issue\" : [{ \"severity\" : \"error\" , \"code\" : \"processing\" , \"details\" : { \"coding\" : [{ \"system\" : \"https://smarthealth.cards\" , \"code\" : \"no-did-bound\" , \"display\" : \"No DID is bound to the requested Patient account\" }] } }] } Presenting Lab Results to a Verifier \u00b6 In this step, the verifier asks the user to share a COVID-19 result. The overall flow is similar to \"Connect Health Wallet to lab account\" above, in that it follows the DID SIOP protocol. Initiate the Presentation This step can happen in person or online. sequenceDiagram participant Holder participant Verifier Verifier ->> Verifier: generate openid:// link with upload URL, public key and presentation context note over Holder, Verifier: In Person Presentation Verifier ->> Verifier: Display openid:// link in QR code Verifier ->> Holder: Holder scans QR code note over Holder, Verifier: Online Presentation Verifier ->> Verifier: redirect with openid:// link Verifier ->> Holder: process redirect Complete the Presentation sequenceDiagram participant Holder participant Verifier Holder ->> Holder: find VCs suitable for presentation context Holder ->> Holder: let user pick VC to share Holder ->> Holder: confirm sharing Holder ->> Holder: encrypt VC with Verifier's public key Holder ->> Verifier: send encrypted VC Verifier ->> Verifier: decrypt VC note over Holder, Verifier: Verify VC Verifier ->> Verifier: validate JWT Verifier ->> Verifier: extract labs DID and resolve Verifier ->> Verifier: ... Presentation Protocol Details The process begins with a QR code or openid:// link. The only differences are: The SIOP Request Object includes a claims object asking for relevant Verifiable Credentials to be included in the response: { // ... o t her reques t f ields like // `iss` , `respo nse _ t ype` , e t c \"claims\" : { \"id_token\" : { \"https://smarthealth.cards#covid19\" : { \"essential\" : true }, } } } Based on the requested claims, the Health Wallet prompts the user to share specific verifiable credentials (in the example above: Health Cards). The selected credentials are packaged into a Verifiable Presentation according to W3C Verifiable Presentations . The id_token constituting the DID SIOP Response includes a .vp.verifiableCredential array: { // ... o t her respo nse f ields like // `iss` , `aud` , e t c. \"vp\" : { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" ], \"type\" : [ \"VerifiablePresentation\" ], \"verifiableCredential\" : [ \"<<Verifiable Credential as JWS>>\" , \"<<Verifiable Credential as JWS>>\" ] } } Potential Extensions \u00b6 Fallback for smartphone-based offline presentation We should be able to specify additional \"return paths\" in the DID SIOP workflow that don't depend on an HTTP upload but instead rely on local transfer (e.g., via NFC or bluetooth) Fallback for users without a smartphone While it's hard to provide the same level of functionality and convenience without a mobile phone, there are still steps we can take to allow broader use of these verifiable credentials. Here's one possibleS approach to graceful degradation: Lab generates VCs that aren't bound to any specific user DID Lab makes VCs available for download User prints a QR Code conveying the VC, or a link to a hosted copy of the VC (optionally protected by a password or PIN) Verifier scans the barcode, retrieves the VC, and verifies signatures -- then relies on out-of band relationship with the user to match the VC to a real-world identity. For example, the user may be an employee or customer of the verifier, and thus the user's name and phone number may be known by the verifier in advance. The verifier must compare the identity attributes inside the VC with the attributes they have verified out of band.","title":"Protocol"},{"location":"#status","text":"Draft implementation guide authored with input from technology and lab vendors; created in conjunction with four independent software implementations.","title":"Status"},{"location":"#contributing","text":"To propose changes, please use GitHub Issues or create a Pull Request .","title":"Contributing"},{"location":"#overview-video-november-2020","text":"https://youtu.be/UdlmRoJK1Yg","title":"Overview Video (November 2020)"},{"location":"#introduction-health-cards","text":"This implementation guide provides a framework for \"Health Cards\", with a short term goal to enable a consumer to receive COVID-19 Immunization or lab results and present these results to another party in a verifiable manner . Key use cases include conveying point-in-time infection status for return-to-workplace and travel. This approach should also support documentation of immunization status and other health details. Because we must ensure end-user privacy and because Health Cards must work across organizational and jurisdictional boundaries, we are building on international open standards and decentralized infrastructure.","title":"Introduction -- Health Cards"},{"location":"#conceptual-model","text":"Issuer (e.g., a lab) generates verifiable credentials Holder stores credentials and presents them at will Verifier receives credentials from holder and ensures they are properly signed","title":"Conceptual Model"},{"location":"#design-goals","text":"Support end-to-end workflow where users receive and present relevant healthcare data Enable workflow with open standards Support strong cryptographic signatures Support binding credentials to keys stored on a user's device Enable privacy preserving data presentations for specific use cases","title":"Design Goals"},{"location":"#start-small-think-big","text":"We enable Health Cards by defining building blocks that can be used across healthcare. The core building block allows us to aggregate data into meaningful sets, signed by an issuer, and stored/presented by a consumer as needed. The broader set of use cases might eventually include: Managing an immunization record that can be shared with schools or employers, or for travel Sharing verifiable health history data with clinical research studies Sharing voluntary data with public health agencies Sharing questionnaire responses with healthcare providers Despite this broad scope, our short-term definition of success requires that we: Represent \"Health Cards\" in a \"Health Wallet\", focusing on COVID-19 status Ensure that each role (issuer, holder, app) can be implemented by any organization following open standards, provided they sign on to the relevant trust framework Align with a longer term vision for standards-based decentralized identity, where each role (issuer, holder, app)","title":"Start Small -- Think Big"},{"location":"#user-experience","text":"Install a \"Health Wallet\" app Connect the Health Wallet to a lab account Save a COVID-19 results card from the lab to the Health Wallet When a user wants to share COVID-19 results with a verifier: a) Open Health Wallet b) Scan a QR code displayed by verifier c) Agree when prompted with \"Share COVID-19 results with {Verifier Name }?\"","title":"User Experience"},{"location":"#demo","text":"Sometimes it's easiest to learn by seeing. For an end-to-end demonstration including Mobile Wallet, Lab API, and Verifier, see c19.cards (source code on GitHub -- and if you want to learn how to test your own components against the demo site, see README.md ).","title":"Demo"},{"location":"#design-considerations","text":"This section outlines higher-level design considerations. See \"Protocol Details\" below for technical details.","title":"Design Considerations"},{"location":"#data-flow","text":"Each step in the flow must have well-defined inputs and outputs. For each step we define at least one required data transfer method to establish a basis for interoperability.","title":"Data Flow"},{"location":"#trust","text":"Which issuers can participate, which test results should be considered, and how do verifiers learn this information? At a pilot project level :","title":"Trust"},{"location":"#privacy","text":"It is an explicit design goal to let the holder only disclose a minimum amount of information to a verifier. The information required to be disclosed is use-case dependent, and -- particularly in a healthcare setting -- it can be difficult for lay people to judge which data elements are necessary to be shared. To start, the granularity of information disclosure will be at the level of an entire credential (i.e., a user can select \"which cards\" to share from a Health Wallet, and each card is shared wholesale). The credentials are designed to only include the minimum information necessary for a given use case. If we identify optional data elements for a given use case, we might incorporate them into credentials by including a cryptographic hash of their values instead of embedding values directly. Longer term we can provide more granular options using techniques like zero-knowledge proofs, or by allowing a trusted intermediary to sumamrize results in a just-in-time fashion.","title":"Privacy"},{"location":"#data-model","text":"The credential's data is represented in FHIR as outlined in Modeling Verifiable Credentials in FHIR","title":"Data Model"},{"location":"#protocol-details","text":"","title":"Protocol Details"},{"location":"#install-a-health-wallet-app","text":"In this step, the user installs a standards-based mobile app. The app generates a decentralized identifier on behalf of the user, including: a key of type JsonWebKey2020 to enable verification of JWT signatures created by the wallet, using the \"alg\": \"ES256\" signature algorithm a key of type JsonWebKey2020 to enable encryption of JWE payloads created for this wallet, using the \"alg\": \"ECDH-ES\" and \"enc\": \"A256GCM\" encryption algorithm Signature and encryption algorithms There are different cryptographic algorithms, with trade-offs. It's useful to pick algorithms for consistent implementations -- so we're starting with ES256 for verification and ECDH-ES + A256GCM for encryption, but should continue to evaluate this choice as requirements emerge. This identifier conforms to the did:ion method . The did:ion method is an implementation of the Sidetree specification : a spec for DID methods using distributed ledgers. ION DIDs will be used to secure interactions with the issuer and the verifier, from here on out. DID Methods There are different DID methods, with trade-offs. It's useful to pick an approach that: works for issuers as well as holders works peer-to-peer or anchored to a public record supports key rotation supports distinct keys per-device supports service endpoint discovery So we're starting with did:ion , but should continue to evaluate this choice as requirements emerge. Long-form vs. Short-form DIDs did:ion , a Sidetree-compliant DID method, supports both long and short form DIDs. In brief, a long-form DID can be resolved to a DID Document on its own: it does not require a blockchain query to provide information about the public key information state of an identity. A short-form DID requires a blockchain query to resolve a DID Document and requires that the corresponding long-form DID be persisted to the blockchain before the short-form DID is resolvable. As such, communicating via short-form DIDs requires more capabilities/infrastructure: namely integrating with a Sidetree node to resolve these short-form DIDs. However, this infrastructure enables a more robust security model. You need to persist a DID Document in the blockchain to resolve a short-form DID, persisting a DID Document in the blockchain enables a DID to be updated via key revocation, key addition, etc. Check out the documentation on DID URI Composition and DID Resolution for more details. This implementation guide recommends using strictly long-form ION DIDs at this time.","title":"Install a \u201cHealth Wallet\u201d app"},{"location":"#connect-health-wallet-to-lab-account","text":"In this step, the lab learns about the end-user's DID. To accomplish this, the lab initiates an OpenID Connect request associated with the user's account (e.g., by displaying a link or a QR code in the portal, or by hosting a FHIR API endpoint that allows a third-party app to initiate an OIDC request). The specific OpenID Connect profile we use is called \"DID SIOP\" . Discovering DIDs for labs To ensure that all parties can maintain an up-to-date list of DIDs for known labs, each lab hosts a /.well-known/did-configuration.json file on the same domain as .registration.client_uri lives on, so parties such as the Health Wallet app can maintain a list of DIDs for each domain. sequenceDiagram participant Device as User's Device participant Lab Device ->> Device: Create users DID:ION: keys Lab ->> Lab: Create DID:ION: keys note over Device: Later, either [A], [B] or [C]... Lab -->> Device: [A] Click `openid://` link on issuer's portal Lab -->> Device: [B] Scan QR code or NFC tag with `openid://` link Device -->> Lab: [C] FHIR $HealthWallet.connect Lab -->> Device: [C] Return `openid://` link in FHIR Parameters resource Device ->> Device: React to `openid` link Device ->> Device: Validate prompt note over Device: Ask user to connect Device ->> Lab: Issue request to `request_uri` Lab ->> Lab: Generate DID SIOP request with lab's keys Lab ->> Device: Return DID SIOP Request Device ->> Device: Validate DID SIOP JWT note over Device: Ask user to share keys Device ->> Device: Formulate DID SIOP Response Device ->> Lab: Submit response ([C] with Authorization header) Lab ->> Lab: Store keys to user account Lab ->> Device: Ack","title":"Connect Health Wallet to Lab Account"},{"location":"#lab-generates-results","text":"When the lab performs tests and the results come in, the lab creates a FHIR payload and a corresponding VC. sequenceDiagram participant Holder participant Lab note over Holder, Lab: Earlier... Lab ->> Lab: Generate Lab's DID Holder -->> Lab: Upload DID Lab ->> Lab: If labs for holder already exist: re-generate VCs note over Lab, Holder: Lab Result Created Lab ->> Lab: Generate FHIR Representation Lab ->> Lab: Generate VC Representation Lab ->> Lab: Generate JWT Payload including Holder DID (if known) and sign Lab ->> Lab: Store on holder's account note over Lab, Holder: Later... Lab ->> Holder: Holder downloads VCs See Modeling Verifiable Credentials in FHIR for details. The overall VC structure looks like the following: VCs look different when represented as JWTs The example below shows a VC using the \"vanilla\" JSON representation. When packaging a VC into a JSON Web Token payload, there are a few differences, to retain compatibility with standard JWT claims. For example, compare this \"vanilla\" JSON representation with its corresponding JWT payload . Note that in the JWT payload, most properties have been pushed into a .vc claim. { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" ], \"type\" : [ \"VerifiableCredential\" , \"https://smarthealth.cards#covid19\" , ], \"issuer\" : \"<<did:ion identifier for lab>>\" , \"issuanceDate\" : \"2020-05-01T11:59:00-07:00\" , \"credentialSubject\" : { \"id\" : \"<<did:identifier for holder if known>>\" , \"fhirVersion\" : \"<<FHIR Version>>\" , \"fhirBundle\" : { \"resourceType\" : \"Bundle\" , \"type\" : \"collection\" , \"entry\" : [ <<FHIR Resources>> ] } } }","title":"Lab Generates Results"},{"location":"#lab-results-are-finalized","text":"In this step, the user learns that new lab results are available (e.g., by receiving a text message or email notification). To facilitate this workflow, the lab can include a link to help the user download the credentials directly, e.g., from at a login-protected page in the Lab's patient portal. The file should be served with a .fhir-backed-vc file extension, so the Health Wallet app can be configured to recognize this extension. Contents should be a JSON object containing an array of Verifiable Credential JWTs, which MAY be either JWE or JWS, at the issuer's discretion: in the case where the user has NOT connected a wallet to the issuer in advance, these will necessarily be JWS values, since no encryption key is known in the case where the user has connected a health wallet to the issuer, the issuer MAY choose to encrypt the .fhir-backed-vc file using a key from the Health Wallet's registered DID { \"verifiableCredential\" : [ \"<<Verifiable Credential as JWE or JWS (see above)>>\" , \"<<Verifiable Credential as JWE or JWS (see above)>>\" ] } Finally, the Health Wallet asks the user if they want to save any/all of the supplied credentials. Requesting VCs through the FHIR API The file download is the lowest common denominator. For a more seamless user experience when FHIR API connections are already in place, results may also be conveyed through a FHIR API $HealthWallet.issueVc operation defined here. FHIR API Example Approach","title":"Lab Results are Finalized"},{"location":"#presenting-lab-results-to-a-verifier","text":"In this step, the verifier asks the user to share a COVID-19 result. The overall flow is similar to \"Connect Health Wallet to lab account\" above, in that it follows the DID SIOP protocol.","title":"Presenting Lab Results to a Verifier"},{"location":"#potential-extensions","text":"","title":"Potential Extensions"},{"location":"changelog/","text":"Changelog \u00b6 0.0.11 \u00b6 Change canonical domain to https://smarthealth.cards (from https://healthwallet.cards) 0.0.10 \u00b6 Add detail on how to recognize encryption keys, signing keys, and linked domains in a DID Document 0.0.9 \u00b6 Add discovery params to .well-known/smart-configuration , allowing SMART on FHIR servers to advertise Health Cards capabilities 0.0.8 \u00b6 Clarify that .fhir-backed-vc files can contain JWS- or JWE-based VCs Update JWS signature algorithm to ES256 0.0.7 \u00b6 Simplify demographics recommendations with one uniform \"minimum set\" 0.0.6 \u00b6 Updated encryption to use \"alg\": \"ECDH-ES\" (with \"enc\": \"A256GCM\" ) 0.0.5 \u00b6 Updated encryption to use \"enc\": \"A256GCM\" 0.0.4 \u00b6 Added links to overview / intro video Updated SIOP request to identify requested credentials by type URL ( https://healthwallet.cards#covid19 instead of health-wallet-covid19-card ) 0.0.3 \u00b6 Update .well-known DID links and file URL to match latest spec 0.0.2 \u00b6 Use valueUri (which exists in DSTU2+) for FHIR datatypes rather than valueUrl (which was introduced after DSTU2) Added encryptForKeyId parameter to $HealthWallet.issueVc operation, defaulting to absent == no encryption Updated example VC JWT representations to ensure that the .vc.credentialSubject contains all subject-specific claims Defined OperationOutcome payload for failed $HealthWallet.issueVc operations","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#0011","text":"Change canonical domain to https://smarthealth.cards (from https://healthwallet.cards)","title":"0.0.11"},{"location":"changelog/#0010","text":"Add detail on how to recognize encryption keys, signing keys, and linked domains in a DID Document","title":"0.0.10"},{"location":"changelog/#009","text":"Add discovery params to .well-known/smart-configuration , allowing SMART on FHIR servers to advertise Health Cards capabilities","title":"0.0.9"},{"location":"changelog/#008","text":"Clarify that .fhir-backed-vc files can contain JWS- or JWE-based VCs Update JWS signature algorithm to ES256","title":"0.0.8"},{"location":"changelog/#007","text":"Simplify demographics recommendations with one uniform \"minimum set\"","title":"0.0.7"},{"location":"changelog/#006","text":"Updated encryption to use \"alg\": \"ECDH-ES\" (with \"enc\": \"A256GCM\" )","title":"0.0.6"},{"location":"changelog/#005","text":"Updated encryption to use \"enc\": \"A256GCM\"","title":"0.0.5"},{"location":"changelog/#004","text":"Added links to overview / intro video Updated SIOP request to identify requested credentials by type URL ( https://healthwallet.cards#covid19 instead of health-wallet-covid19-card )","title":"0.0.4"},{"location":"changelog/#003","text":"Update .well-known DID links and file URL to match latest spec","title":"0.0.3"},{"location":"changelog/#002","text":"Use valueUri (which exists in DSTU2+) for FHIR datatypes rather than valueUrl (which was introduced after DSTU2) Added encryptForKeyId parameter to $HealthWallet.issueVc operation, defaulting to absent == no encryption Updated example VC JWT representations to ensure that the .vc.credentialSubject contains all subject-specific claims Defined OperationOutcome payload for failed $HealthWallet.issueVc operations","title":"0.0.2"},{"location":"credential-modeling/","text":"Modeling W3C Verifiable Credentials in FHIR \u00b6 This document describes how healthcare data, modeled in FHIR , can be presented in the form of a W3C Verifiable Credential (VC). Content Definition \u00b6 Any time we want to present healthcare data in the form of a VC, we must first make some use-case-specific decisions: Define a set of required and optional FHIR content resources (e.g., Immunization or Observation ) that must be packaged and presented together Decide how to bind these FHIR content resources to a person's external identity, via FHIR identity resources (e.g., Patient ) Once we make these decisions, we can construct a VC with a credential subject as follows: credentialSubject with these top level elements: fhirVersion : a string representation of the semantic FHIR version the content is represented in (e.g. 1.0.* for DSTU2, 4.0.* for R4, where * is a number, not a literal asterisk) fhirBundle : a FHIR Bundle resource of type \"collection\" that includes all required FHIR resources (content + identity resources) Resulting payload structure: { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" ], ... \"credentialSubject\" : { \"fhirVersion\" : \"4.0.1\" , \"fhirBundle\" : { \"resourceType\" : \"Bundle\" , \"type\" : \"collection\" , \"entry\" : [ ... ] } } } Below we focus on the Health Card use case, but the same approach to forming VCs out of FHIR can be applied to other use cases, too. Modeling a \"Health Card\" \u00b6 A \"Health Card\" is a VC that conveys results about one discrete condition -- in this case a single COVID-19 serology study , encompassing IgG and IgM detection. Other cards could convey details of a RT-PCR test for COVID-19, a clinical diagnosis of COVID-19, TDAP vaccination, and so on. According to the procedure above, we start with decisions about FHIR content resources and identity resources: Which FHIR content resources need to be conveyed in a package? For the diagnostic results, we need: Observation with effectiveTime and a COVID-19 IgM result Observation with effectiveTime and a COVID-19 IgG result DiagnosticReport from COVID-19 testing, that conveys an overall conclusion (optional) What FHIR identity resources do we need to bind the FHIR content resources to an external identity system? We might eventually define use-case-specific requirements, but we want to start with on recommended set of data elements for inclusion using the FHIR Patient resource: First name Middle initial Last Name Suffix Gender Mobile phone Email address Date of birth Overall \"level of assurance\" indicating whether these elements have been verified (question: do we also want to convey element-specific level of assurance?) Best practices Each party should attempt to verify the mobile phone number (e.g., using an SMS with a confirmation link or one-time code) Verifiers should not store identity data conveyed via VC, and should delete data as soon as they are no longer needed for verification purposes Verifiers should not expect all elements in the VC to match their own records, but can still use elements conveyed in the VC. For example, if a user has registered a verifier-specific email addresses in the VC, the verifier might use the email address inside the VC as a second factor in a verifiaction workflow Health Card Examples Example VC in expanded form JWT representation","title":"Credentials"},{"location":"credential-modeling/#modeling-w3c-verifiable-credentials-in-fhir","text":"This document describes how healthcare data, modeled in FHIR , can be presented in the form of a W3C Verifiable Credential (VC).","title":"Modeling W3C Verifiable Credentials in FHIR"},{"location":"credential-modeling/#content-definition","text":"Any time we want to present healthcare data in the form of a VC, we must first make some use-case-specific decisions: Define a set of required and optional FHIR content resources (e.g., Immunization or Observation ) that must be packaged and presented together Decide how to bind these FHIR content resources to a person's external identity, via FHIR identity resources (e.g., Patient ) Once we make these decisions, we can construct a VC with a credential subject as follows: credentialSubject with these top level elements: fhirVersion : a string representation of the semantic FHIR version the content is represented in (e.g. 1.0.* for DSTU2, 4.0.* for R4, where * is a number, not a literal asterisk) fhirBundle : a FHIR Bundle resource of type \"collection\" that includes all required FHIR resources (content + identity resources) Resulting payload structure: { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" ], ... \"credentialSubject\" : { \"fhirVersion\" : \"4.0.1\" , \"fhirBundle\" : { \"resourceType\" : \"Bundle\" , \"type\" : \"collection\" , \"entry\" : [ ... ] } } } Below we focus on the Health Card use case, but the same approach to forming VCs out of FHIR can be applied to other use cases, too.","title":"Content Definition"},{"location":"credential-modeling/#modeling-a-health-card","text":"A \"Health Card\" is a VC that conveys results about one discrete condition -- in this case a single COVID-19 serology study , encompassing IgG and IgM detection. Other cards could convey details of a RT-PCR test for COVID-19, a clinical diagnosis of COVID-19, TDAP vaccination, and so on. According to the procedure above, we start with decisions about FHIR content resources and identity resources: Which FHIR content resources need to be conveyed in a package? For the diagnostic results, we need: Observation with effectiveTime and a COVID-19 IgM result Observation with effectiveTime and a COVID-19 IgG result DiagnosticReport from COVID-19 testing, that conveys an overall conclusion (optional) What FHIR identity resources do we need to bind the FHIR content resources to an external identity system? We might eventually define use-case-specific requirements, but we want to start with on recommended set of data elements for inclusion using the FHIR Patient resource: First name Middle initial Last Name Suffix Gender Mobile phone Email address Date of birth Overall \"level of assurance\" indicating whether these elements have been verified (question: do we also want to convey element-specific level of assurance?) Best practices Each party should attempt to verify the mobile phone number (e.g., using an SMS with a confirmation link or one-time code) Verifiers should not store identity data conveyed via VC, and should delete data as soon as they are no longer needed for verification purposes Verifiers should not expect all elements in the VC to match their own records, but can still use elements conveyed in the VC. For example, if a user has registered a verifier-specific email addresses in the VC, the verifier might use the email address inside the VC as a second factor in a verifiaction workflow","title":"Modeling a \"Health Card\""},{"location":"vocabulary/","text":"Health Wallet Vocab \u00b6 Verifiable Credential (VC) Types \u00b6 https://smarthealth.cards#covid19 : A VC designed to convey COVID-19 details https://smarthealth.cards#immunization : A VC designed to convey any immunization details https://smarthealth.cards#presentation-context-online : A VC designed for online presentation https://smarthealth.cards#presentation-context-in-person : A VC designed for in-person presentation FHIR Extensions \u00b6 https://smarthealth.cards#vc-attachment : Extension that decorates a FHIR \"key resource\" to attach a VC FHIR Codings \u00b6 The following codes are defined in the https://smarthealth.cards system: no-did-bound : Used for OperationOutcome.issue.code when the Patient/:id/$HealthWallet.issueVc operation fails because no DID is bound to the Patient record covid19 : Used for tagging a FHIR \"key resource\" as containing a VC of type https://smarthealth.cards#covid19 . For use in tagging a FHIR \"key resource\" (in .meta.tag ) as containing a specific type of VC. This facilitates search across FHIR resources to find resources with attached VCs. immunization : Used for tagging a FHIR \"key resource\" as containing a VC of type https://smarthealth.cards#immunization . For use in tagging a FHIR \"key resource\" (in .meta.tag ) as containing a specific type of VC. This facilitates search across FHIR resources to find resources with attached VCs.","title":"Vocabulary"},{"location":"vocabulary/#health-wallet-vocab","text":"","title":"Health Wallet Vocab"},{"location":"vocabulary/#verifiable-credential-vc-types","text":"https://smarthealth.cards#covid19 : A VC designed to convey COVID-19 details https://smarthealth.cards#immunization : A VC designed to convey any immunization details https://smarthealth.cards#presentation-context-online : A VC designed for online presentation https://smarthealth.cards#presentation-context-in-person : A VC designed for in-person presentation","title":"Verifiable Credential (VC) Types"},{"location":"vocabulary/#fhir-extensions","text":"https://smarthealth.cards#vc-attachment : Extension that decorates a FHIR \"key resource\" to attach a VC","title":"FHIR Extensions"},{"location":"vocabulary/#fhir-codings","text":"The following codes are defined in the https://smarthealth.cards system: no-did-bound : Used for OperationOutcome.issue.code when the Patient/:id/$HealthWallet.issueVc operation fails because no DID is bound to the Patient record covid19 : Used for tagging a FHIR \"key resource\" as containing a VC of type https://smarthealth.cards#covid19 . For use in tagging a FHIR \"key resource\" (in .meta.tag ) as containing a specific type of VC. This facilitates search across FHIR resources to find resources with attached VCs. immunization : Used for tagging a FHIR \"key resource\" as containing a VC of type https://smarthealth.cards#immunization . For use in tagging a FHIR \"key resource\" (in .meta.tag ) as containing a specific type of VC. This facilitates search across FHIR resources to find resources with attached VCs.","title":"FHIR Codings"}]}